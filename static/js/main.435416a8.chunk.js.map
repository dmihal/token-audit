{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["accounts","statuses","pending","running","fraud","complete","App","useState","provider","setProvider","address","setAddress","setRunning","startBlock","setStartBlock","totalSupply","setTotalSupply","calculatedSupply","setCalculatedSupply","calcSupplyLessBurn","setCalculatedSupplyLessBurn","numAccounts","setNumAccounts","block","setBlock","status","setStatus","scan","a","web3Provider","window","ethereum","web3","Web3","token","eth","Contract","erc20","methods","call","_supply","_calculatedSupply","_calculatedSupplyLessBurn","_numAccounts","adjustAccount","account","val","direction","toBN","add","gt","Error","sub","getBlockNumber","currentBlock","_startBlock","parseInt","fromBlock","getPastEvents","toBlock","events","event","returnValues","from","utils","value","toString","to","console","log","className","type","name","disabled","checked","onClick","onChange","e","target","placeholder","fromWei","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.435416a8.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport './App.css';\nimport erc20 from './IERC20.json';\nimport Web3 from 'web3';\nimport { toBN, fromWei } from 'web3-utils';\n\nconst SCAN_SIZE = 3000;\n\nlet accounts = {};\n\nconst statuses = {\n  pending: 'Waiting to start',\n  running: 'Auditing transactions...',\n  fraud: 'Fraud discovered!',\n  complete: 'Token history verified successfully',\n};\n\nfunction App() {\n  const [provider, setProvider] = useState(null);\n  const [address, setAddress] = useState('0xc00e94cb662c3520282e6f5717214004a7f26888');\n  const [running, setRunning] = useState(false);\n  const [startBlock, setStartBlock] = useState('9601359');\n  const [totalSupply, setTotalSupply] = useState('');\n  const [calculatedSupply, setCalculatedSupply] = useState('0');\n  const [calcSupplyLessBurn, setCalculatedSupplyLessBurn] = useState('0');\n  const [numAccounts, setNumAccounts] = useState(0);\n  const [block, setBlock] = useState(0);\n  const [status, setStatus] = useState('pending');\n\n  const scan = async () => {\n    setRunning(true);\n    setStatus('running');\n\n    const web3Provider = provider === 'injected'\n      ? window.ethereum\n      : provider;\n\n    const web3 = new Web3(web3Provider);\n    const token = new web3.eth.Contract(erc20, address);\n\n    const _supply = await token.methods.totalSupply().call();\n    setTotalSupply(_supply);\n\n    let _calculatedSupply = '0';\n    let _calculatedSupplyLessBurn = '0';\n    let _numAccounts = 0;\n\n    const adjustAccount = (account, val, direction) => {\n      if (!accounts[account]) {\n        _numAccounts++;\n        setNumAccounts(_numAccounts);\n        accounts[account] = toBN('0');\n      }\n\n      if (direction === 'in') {\n        accounts[account] = accounts[account].add(toBN(val));\n      } else {\n        if (toBN(val).gt(accounts[account])) {\n          throw new Error('Fraud!');\n        }\n        accounts[account] = accounts[account].sub(toBN(val));\n      }\n    }\n\n    let currentBlock = await web3.eth.getBlockNumber();\n\n    const _startBlock = parseInt(startBlock);\n    for (let fromBlock = _startBlock; fromBlock < currentBlock + SCAN_SIZE; fromBlock += SCAN_SIZE) {\n      setBlock(fromBlock);\n      const events = await token.getPastEvents(['Mint', 'Burn'], {\n        fromBlock, toBlock: fromBlock + SCAN_SIZE - 1,\n      });\n\n      for (const event of events) {\n        try {\n          if (event.event === 'Transfer' && event.returnValues.from === '0x0000000000000000000000000000000000000000') {\n            _calculatedSupply = web3.utils.toBN(_calculatedSupply).add(web3.utils.toBN(event.returnValues.value)).toString();\n            setCalculatedSupply(_calculatedSupply);\n\n            _calculatedSupplyLessBurn = web3.utils.toBN(_calculatedSupplyLessBurn).add(web3.utils.toBN(event.returnValues.value)).toString();\n            setCalculatedSupplyLessBurn(_calculatedSupplyLessBurn);\n\n            if (!accounts[event.returnValues.to]) {\n              adjustAccount(event.returnValues.to, event.returnValues.value, 'in');\n            }\n          } else if (event.event === 'Transfer') {\n            adjustAccount(event.returnValues.from, event.returnValues.value, 'out');\n            adjustAccount(event.returnValues.to, event.returnValues.value, 'in');\n\n            if (event.returnValues.to === '0x0000000000000000000000000000000000000000') {\n              _calculatedSupplyLessBurn = web3.utils.toBN(_calculatedSupplyLessBurn).sub(web3.utils.toBN(event.returnValues.value)).toString();\n              setCalculatedSupplyLessBurn(_calculatedSupplyLessBurn);\n            }\n          }\n        } catch (e) {\n          console.log('fraud', event, accounts[event.returnValues.to].toString(), accounts[event.returnValues.from].toString());\n          setRunning(false);\n          setStatus('fraud');\n          return;\n        }\n      }\n    }\n\n    setRunning(false);\n    setStatus('complete');\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <div>\n          Connect to a node:\n        </div>\n        <div>\n          <label>\n            <input type=\"radio\" name=\"node\" disabled={!window.ethereum} checked={provider === 'injected'} onClick={() => setProvider('injected')} />\n            Injected provider (Metamask)\n          </label>\n        </div>\n        <div>\n          <label>\n            <input type=\"radio\" name=\"node\" disabled={!window.ethereum} checked={provider && provider !== 'injected'} />\n            <input value={(provider && provider !== 'injected') ? provider : ''} onChange={e => setProvider(e.target.value)} placeholder=\"JSONRPC URL\" />\n          </label>\n        </div>\n\n        <div>\n          Token address\n          <input value={address} onChange={e => setAddress(e.target.value)} disabled={running} />\n        </div>\n\n        <div>\n          Token deploy block\n          <input type=\"number\" value={startBlock} onChange={e => setStartBlock(e.target.value)} disabled={running} />\n        </div>\n\n        <button disabled={running || !provider} onClick={scan}>Scan</button>\n        <div>{statuses[status]}</div>\n\n        <div>totalSupply(): {fromWei(totalSupply, 'ether')}</div>\n        <div>Calculated supply: {fromWei(calculatedSupply, 'ether')}</div>\n        <div>Calculated supply (excluding burns): {fromWei(calcSupplyLessBurn, 'ether')}</div>\n        <div>Number of accounts: {numAccounts}</div>\n        <div>Block: {block}</div>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}